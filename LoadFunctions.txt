#Write-Host "`n - Retrieving Maule Technologies PowerShell Functions via Git -"
Set-ExecutionPolicy Bypass -Scope Process -Force

$bootTimer = [System.Diagnostics.Stopwatch]::StartNew()

# Set default IT folder path if not already defined
if (-not $ITFolder) {
    $Global:ITFolder = "$Env:SystemDrive\IT"
}

# Enable TLS 1.2/1.1/1.0
[System.Net.ServicePointManager]::SecurityProtocol = 3072 -bor 768 -bor 192

# Function to check if git is installed
Function Test-GitInstalled {
    param([string]$GitPath = "$ITFolder\GitHub\PortableGit\bin\git.exe")

    if (Test-Path $GitPath) {
        return $true
    }

    # Also check system PATH
    try {
        $null = git --version 2>$null
        return $true
    }
    catch {
        return $false
    }
}

# Function to install Git Portable
Function Install-GitPortable {
    $GitFolder = "$ITFolder\GitHub\PortableGit"
    $TempPath = "$env:TEMP\GitPortable"

    try {
        # Create directories if they don't exist
        Write-Host "Creating directories..." -ForegroundColor Green
        New-Item -ItemType Directory -Path $GitFolder -Force | Out-Null
        New-Item -ItemType Directory -Path $TempPath -Force | Out-Null

        # Get latest Git release info from GitHub API
        Write-Host "Fetching latest Git release information..." -ForegroundColor Green
        $LatestRelease = Invoke-RestMethod -Uri "https://api.github.com/repos/git-for-windows/git/releases/latest"

        # Extract version from tag (e.g., "v2.50.1.windows.1" -> "2.50.1")
        $LatestVersionRaw = $LatestRelease.tag_name -replace '^v', ''
        $LatestVersionParts = $LatestVersionRaw -split '\.'
        $LatestVersion = "$($LatestVersionParts[0]).$($LatestVersionParts[1]).$($LatestVersionParts[2])"

        # Check if Git is already installed and up to date
        $GitExePath = "$GitFolder\bin\git.exe"
        if (Test-Path $GitExePath) {
            Write-Host "Found existing Git installation, checking version..." -ForegroundColor Yellow

            try {
                $CurrentVersionInfo = (Get-Item $GitExePath).VersionInfo
                $CurrentVersion = "$($CurrentVersionInfo.ProductMajorPart).$($CurrentVersionInfo.ProductMinorPart).$($CurrentVersionInfo.ProductBuildPart)"

                Write-Host "Current version: $CurrentVersion" -ForegroundColor Cyan
                Write-Host "Latest version:  $LatestVersion" -ForegroundColor Cyan

                if ([System.Version]$CurrentVersion -ge [System.Version]$LatestVersion) {
                    Write-Host "Git Portable is already up to date!" -ForegroundColor Green
                    return $true
                } else {
                    Write-Host "Update available, proceeding with download..." -ForegroundColor Yellow
                }
            } catch {
                Write-Host "Could not determine current version, proceeding with download..." -ForegroundColor Yellow
            }
        } else {
            Write-Host "Git Portable not found, proceeding with fresh installation..." -ForegroundColor Yellow
        }

        # Find the portable x64 asset
        $PortableAsset = $LatestRelease.assets | Where-Object {
            $_.name -like "PortableGit*64-bit*" -and $_.name -like "*.exe"
        }

        if (-not $PortableAsset) {
            throw "Could not find Git Portable 64-bit asset in latest release"
        }

        $DownloadUrl = $PortableAsset.browser_download_url
        $FileName = $PortableAsset.name
        $FilePath = "$TempPath\$FileName"

        Write-Host "Found: $FileName" -ForegroundColor Yellow
        Write-Host "Downloading from: $DownloadUrl" -ForegroundColor Yellow

        # Download the file
        Write-Host "Downloading Git Portable..." -ForegroundColor Green
        try {
            $ProgressPreference = 'SilentlyContinue'
            Invoke-WebRequest -Uri $DownloadUrl -OutFile $FilePath
        } finally {
            $ProgressPreference = 'Continue'
        }

        Write-Host "Download completed: $([math]::Round((Get-Item $FilePath).Length / 1MB, 2)) MB" -ForegroundColor Green

        # Extract the 7zip self-extractor
        Write-Host "Extracting Git Portable to $GitFolder..." -ForegroundColor Green

        # -Wait ensures ExitCode is reliably populated when used with -PassThru
        $Process = Start-Process -FilePath $FilePath -ArgumentList "-y", "-o$GitFolder" -NoNewWindow -Wait -PassThru

        if ($Process.ExitCode -ne 0) {
            throw "7zip extraction failed with exit code: $($Process.ExitCode)"
        }

        # Verify git.exe exists after extraction
        $GitExePath = "$GitFolder\bin\git.exe"
        if (Test-Path $GitExePath) {
            Write-Host "Git Portable successfully extracted!" -ForegroundColor Green

            $GitVersion = & "$GitExePath" --version
            Write-Host "Installed version: $GitVersion" -ForegroundColor Green

        } else {
            throw "Git executable not found after extraction"
        }

        # Cleanup
        Write-Host "Cleaning up temporary files..." -ForegroundColor Green
        Remove-Item -Path $TempPath -Recurse -Force

        Write-Host "`n=== Git Installation Complete ===" -ForegroundColor Cyan
        Write-Host "Git Portable Location: $GitFolder" -ForegroundColor White
        Write-Host "Git Executable: $GitExePath" -ForegroundColor White

        return $true

    } catch {
        Write-Error "Failed to download/extract Git Portable: $($_.Exception.Message)"
        return $false
    }
}

# Function to run git commands using direct process execution (no subprocess overhead)
Function Global:Invoke-Git {
    <#
    .SYNOPSIS
        Runs git commands using System.Diagnostics.Process for fast, isolated execution.

    .DESCRIPTION
        Executes git commands in a separate process using .NET Process API directly,
        avoiding the heavy overhead of Start-Job (which spawns a full powershell.exe).
        Uses ReadToEndAsync for deadlock-free stdout/stderr capture.
        Throws on non-zero exit codes so callers can use try/catch.

    .PARAMETER GitPath
        Path to the git executable. Can be full path or 'git' for system PATH.

    .PARAMETER Arguments
        Array of arguments to pass to git command.

    .PARAMETER WorkingDirectory
        Working directory for the git command. Defaults to current directory.

    .PARAMETER ShowOutput
        If specified, outputs the git command results to the console.

    .OUTPUTS
        Returns the stdout output from the git command as an array of strings.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]$GitPath,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string[]]$Arguments,

        [Parameter(Mandatory=$false)]
        [string]$WorkingDirectory,

        [switch]$ShowOutput
    )

    if (-not $WorkingDirectory) {
        $WorkingDirectory = $PWD.Path
    }

    if (-not [System.IO.Path]::IsPathRooted($WorkingDirectory)) {
        throw "WorkingDirectory must be an absolute path: $WorkingDirectory"
    }

    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName = $GitPath
    # Quote arguments that contain spaces or double quotes
    $psi.Arguments = ($Arguments | ForEach-Object {
        $escaped = $_ -replace '"', '\"'
        if ($_ -match '[\s"]') { "`"$escaped`"" } else { $_ }
    }) -join ' '
    $psi.WorkingDirectory = $WorkingDirectory
    $psi.UseShellExecute = $false
    $psi.RedirectStandardOutput = $true
    $psi.RedirectStandardError = $true
    $psi.CreateNoWindow = $true

    # Prevent git from waiting for terminal input
    $psi.EnvironmentVariables["GIT_TERMINAL_PROMPT"] = "0"

    $process = New-Object System.Diagnostics.Process
    $process.StartInfo = $psi

    try {
        [void]$process.Start()

        # Use ReadToEndAsync to read both streams concurrently (prevents deadlocks)
        $stdoutTask = $process.StandardOutput.ReadToEndAsync()
        $stderrTask = $process.StandardError.ReadToEndAsync()

        # 60 second timeout to prevent hanging on credential prompts or network issues
        if (-not $process.WaitForExit(60000)) {
            $process.Kill()
            throw "Git command timed out after 60 seconds: git $($Arguments -join ' ')"
        }

        $stdout = $stdoutTask.GetAwaiter().GetResult().TrimEnd([char]"`r", [char]"`n")
        $stderr = $stderrTask.GetAwaiter().GetResult().TrimEnd([char]"`r", [char]"`n")
        $output = if ($stdout) { $stdout -split "`r?`n" } else { @() }

        if ($process.ExitCode -ne 0) {
            $cmdString = "git $($Arguments -join ' ')"
            $errorMsg = if ($stderr) { $stderr } elseif ($stdout) { $stdout } else { "Exit code $($process.ExitCode)" }
            throw "Git command '$cmdString' failed: $errorMsg"
        }

        if ($ShowOutput -and $output) {
            $output | Write-Output
        }

        return $output
    }
    finally {
        $process.Dispose()
    }
}

# Check PowerShell version to handle certificate validation appropriately
if ($PSVersionTable.PSVersion.Major -lt 6) {
    # PowerShell 5.1 and below - bypass cert validation for environments with
    # corporate proxy/inspection certificates that aren't in the trusted store
    If (-not ([System.Management.Automation.PSTypeName]'ServerCertificateValidationCallback').Type) {
        $certCallback = @"
            using System;
            using System.Net;
            using System.Net.Security;
            using System.Security.Cryptography.X509Certificates;
            public class ServerCertificateValidationCallback
            {
                public static void Ignore()
                {
                    if(ServicePointManager.ServerCertificateValidationCallback ==null)
                    {
                        ServicePointManager.ServerCertificateValidationCallback +=
                            delegate
                            (
                                Object obj,
                                X509Certificate certificate,
                                X509Chain chain,
                                SslPolicyErrors errors
                            )
                            {
                                return true;
                            };
                    }
                }
            }
"@
        Add-Type $certCallback
        [ServerCertificateValidationCallback]::Ignore()
    }
}

# Set up paths (global so Update-ITFunctions works after script scope ends)
$Global:PWSHFolder = "$ITFolder\GitHub\PWSH"
$Global:FunctionsFolder = "$PWSHFolder\Functions"
$Global:GitExePath = "$ITFolder\GitHub\PortableGit\bin\git.exe"

# Ensure git is installed
if (-not (Test-GitInstalled)) {
    if (-not (Install-GitPortable)) {
        Write-Host "Cannot proceed without Git. Exiting." -ForegroundColor Red
        return
    }
}

# Set git executable path for this session (avoid duplicates)
$gitBinPath = "$ITFolder\GitHub\PortableGit\bin"
if ((Test-Path $GitExePath) -and $env:PATH -notlike "*$gitBinPath*") {
    $env:PATH += ";$gitBinPath"
}

# Determine which git to use (resolved once, reused everywhere)
$Global:GitCommand = if (Test-Path $GitExePath) { $GitExePath } else { "git" }

# Helper to detect current branch with fallback to main
Function Global:Get-CurrentBranch {
    param([string]$Git, [string]$WorkDir)
    try {
        $branchOutput = Invoke-Git -GitPath $Git -Arguments @("branch", "--show-current") -WorkingDirectory $WorkDir
        $branch = ($branchOutput -join "").Trim()
    } catch {
        Write-Warning "Failed to detect current branch: $_"
        $branch = ""
    }
    if ([string]::IsNullOrWhiteSpace($branch)) {
        Write-Warning "Detached HEAD or unknown state, defaulting to main branch"
        $branch = "main"
    }
    return $branch
}

# Clone or update repository
if (Test-Path $PWSHFolder) {
    Write-Host "Updating existing PowerShell Functions repository..." -ForegroundColor Yellow
    try {
        Invoke-Git -GitPath $GitCommand -Arguments @("config", "--global", "safe.directory", $PWSHFolder) -WorkingDirectory $PWSHFolder

        $CurrentBranch = Get-CurrentBranch -Git $GitCommand -WorkDir $PWSHFolder

        # Fetch only the branch we need (faster than fetching all refs)
        Invoke-Git -GitPath $GitCommand -Arguments @("fetch", "origin", $CurrentBranch) -WorkingDirectory $PWSHFolder

        Invoke-Git -GitPath $GitCommand -Arguments @("reset", "--hard", "origin/$CurrentBranch") -WorkingDirectory $PWSHFolder

        Write-Host "Repository updated successfully!" -ForegroundColor Green
    }
    catch {
        Write-Host "Failed to update repository: $_" -ForegroundColor Red
        return
    }
} else {
    Write-Host "Cloning PowerShell Functions repository..." -ForegroundColor Yellow
    try {
        New-Item -ItemType Directory -Force -Path "$ITFolder\GitHub" | Out-Null

        # Shallow clone - only latest commit, single branch (much faster)
        Invoke-Git -GitPath $GitCommand -Arguments @("clone", "--depth", "1", "--single-branch", "https://github.com/MauleTech/PWSH.git", $PWSHFolder) -WorkingDirectory "$ITFolder\GitHub"
        Invoke-Git -GitPath $GitCommand -Arguments @("config", "--global", "safe.directory", $PWSHFolder) -WorkingDirectory $PWSHFolder

        Write-Host "Repository cloned successfully!" -ForegroundColor Green
    }
    catch {
        Write-Host "Failed to clone repository: $_" -ForegroundColor Red
        return
    }
}

# Helper function to import all .psm1 modules from the Functions folder
Function Global:Import-ITModules {
    $files = Get-ChildItem -Path $Global:FunctionsFolder -Filter "*.psm1" -File -ErrorAction SilentlyContinue
    if ($files) {
        $files | ForEach-Object {
            Import-Module $_.FullName -Global -Force -Verbose:$false 3>$null
        }
    }
}

# Silent update function (no output, for internal use)
Function Global:Update-ITPS {
    $CurrentBranch = Get-CurrentBranch -Git $Global:GitCommand -WorkDir $Global:PWSHFolder
    Invoke-Git -GitPath $Global:GitCommand -Arguments @("fetch", "origin", $CurrentBranch) -WorkingDirectory $Global:PWSHFolder | Out-Null
    Invoke-Git -GitPath $Global:GitCommand -Arguments @("reset", "--hard", "origin/$CurrentBranch") -WorkingDirectory $Global:PWSHFolder | Out-Null
    Import-ITModules
}

# User-facing update function with progress output
Function Global:Update-ITFunctions {
    Write-Host "Updating IT Functions from GitHub..." -ForegroundColor Yellow
    if (-not (Test-Path $Global:PWSHFolder)) {
        Write-Host "PowerShell Functions repository not found. Please run the main script again." -ForegroundColor Red
        return
    }
    try {
        $CurrentBranch = Get-CurrentBranch -Git $Global:GitCommand -WorkDir $Global:PWSHFolder
        Write-Host "Current branch: $CurrentBranch" -ForegroundColor Yellow

        Write-Host "Fetching latest changes..." -ForegroundColor Yellow
        Invoke-Git -GitPath $Global:GitCommand -Arguments @("fetch", "origin", $CurrentBranch) -WorkingDirectory $Global:PWSHFolder | Out-Null

        Write-Host "Resetting to origin/$CurrentBranch..." -ForegroundColor Yellow
        Invoke-Git -GitPath $Global:GitCommand -Arguments @("reset", "--hard", "origin/$CurrentBranch") -WorkingDirectory $Global:PWSHFolder | Out-Null

        $commitLine = Invoke-Git -GitPath $Global:GitCommand -Arguments @("log", "--oneline", "-1") -WorkingDirectory $Global:PWSHFolder
        Write-Host "Current commit: $($commitLine -join '')" -ForegroundColor Green

        Import-ITModules
        Write-Host "IT Functions updated and reloaded successfully!" -ForegroundColor Green
    }
    catch {
        Write-Host "Failed to update functions: $_" -ForegroundColor Red
    }
}

# Load functions - just import modules (repo was already updated above)
if (Test-Path $FunctionsFolder) {
    $moduleFiles = Get-ChildItem -Path $FunctionsFolder -Filter "*.psm1" -File
    if ($moduleFiles.Count -gt 0) {
        Write-Host "Loading PowerShell Functions..." -ForegroundColor Yellow
        Import-ITModules

        $LoadedModules = Get-Module | Where-Object { $_.Path -like "$FunctionsFolder*" }
        If ($LoadedModules) {
            $bootTimer.Stop()
            $elapsed = "{0:N1}s" -f $bootTimer.Elapsed.TotalSeconds
            $funcCount = (Get-Command -Module "PS-*" | Sort-Object Name).Count
            Write-Host " $funcCount Functions successfully loaded in $elapsed" -ForegroundColor Green
            Write-Host " - Get-ITFunctions to see commands. Update-ITFunctions to load updates.`n"
        } Else {
            Write-Host "Functions were not successfully loaded. Please check the function files." -ForegroundColor Red
        }
    } else {
        Write-Host "No .psm1 function files found in $FunctionsFolder" -ForegroundColor Yellow
    }
} else {
    Write-Host "No .psm1 function files found in $FunctionsFolder" -ForegroundColor Yellow
}
